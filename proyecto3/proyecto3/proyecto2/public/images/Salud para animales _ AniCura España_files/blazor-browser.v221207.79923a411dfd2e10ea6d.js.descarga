var e={d:(t,o)=>{for(var n in o)e.o(o,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:o[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{hS:()=>s,G_:()=>r,Jj:()=>a,H:()=>c,TS:()=>l,Uj:()=>i,yZ:()=>d,ys:()=>h,PO:()=>p,qA:()=>y,zT:()=>u,gm:()=>w});const o=new Map,n=(e,t)=>{const o=e.innerWidth;t.invokeMethodAsync("OnSetBrowserWidthCallback",o).catch((e=>console.log("Error during browser resize",e)))},s=(e,t)=>e[t],r=(e,t)=>{const s=t=>n(t.target,e);window.addEventListener("resize",s),o.set(t,{callback:s,target:window,types:["resize"]}),n(window,e)},a=(e,t,n)=>{const s=o=>{("undefined"!=typeof TouchEvent&&o instanceof TouchEvent||o instanceof MouseEvent&&0===o.button)&&n.every((e=>!!e&&"function"==typeof e.contains&&!1===e.contains(o.target)))&&e.invokeMethodAsync("OnClickOutsideCallback",t)};document.addEventListener("mouseup",s),document.addEventListener("touchstart",s),o.set(t,{callback:s,target:document,types:["mouseup","touchstart"]})},c=(e,t)=>{const n=t=>{t instanceof KeyboardEvent&&e.invokeMethodAsync("OnKeyCapturedCallback",t.code)};document.addEventListener("keyup",n),o.set(t,{callback:n,target:document,types:["keyup"]})},l=(e,t,n)=>{let s=0,r=!1;const a=n||window,c=t=>{const o=a instanceof HTMLElement?a.scrollTop:a.scrollY,n=a instanceof HTMLElement?a.clientHeight:a.innerHeight,c=a instanceof HTMLElement?a.scrollHeight:a.innerHeight,l=Math.floor(o);l!==s&&(s=l,r||(window.requestAnimationFrame((()=>{s=l;const t=0===s,o=s+n>=c;e.invokeMethodAsync("OnThrottledVerticalScrollCallback",{scrollPosition:s,hasReachedScrollStart:t,hasReachedScrollEnd:o}),r=!1})),r=!0))};a.addEventListener("scroll",c,{passive:!0}),o.set(t,{callback:c,target:a,types:["scroll"]})},i=(e,t,n)=>{let s=0,r=!1;const a=n||window,c=t=>{const o=a instanceof HTMLElement?a.scrollLeft:a.scrollX,n=a instanceof HTMLElement?a.clientWidth:a.innerWidth,c=a instanceof HTMLElement?a.scrollWidth:a.innerWidth,l=Math.floor(o);if(l!==s){s=l;const t=0===s,o=s+n>=c;r||(window.requestAnimationFrame((()=>{e.invokeMethodAsync("OnThrottledHorizontalScrollCallback",{scrollPosition:s,hasReachedScrollStart:t,hasReachedScrollEnd:o}),r=!1})),r=!0)}};a.addEventListener("scroll",c,{passive:!0}),o.set(t,{callback:c,target:a,types:["scroll"]})},d=(e,t,o)=>{(o||window).scrollBy(e,t)},h=e=>{const t=o.get(e);if(t){for(const e of t.types)t.target.removeEventListener(e,t.callback);o.delete(e)}},p=(e,t)=>{const n=t=>{e.invokeMethodAsync("OnBrowserPopstate",t.state).catch((e=>console.log("Error during popstate",e)))};window.addEventListener("popstate",n),o.set(t,{callback:n,target:window,types:["popstate"]})},y=e=>{window.history.pushState({url:window.location.href},"",e)},u=e=>{e.scrollIntoView()},w=async e=>{if(navigator.clipboard)try{await navigator.clipboard.writeText(e.value)}catch(e){console.error(e)}else e.select(),document.execCommand("copy"),e.blur()};var v=t.gm,m=t.PO,f=t.Jj,g=t.H,E=t.G_,k=t.Uj,L=t.TS,b=t.hS,T=t.qA,S=t.ys,M=t.yZ,H=t.zT;export{v as copyInputValue,m as createBrowserHistoryListener,f as createClickOutsideListener,g as createKeyCaptureListener,E as createResizeListener,k as createThrottledHorizontalScrollListener,L as createThrottledVerticalScrollListener,b as getElementProperty,T as pushState,S as removeListener,M as scrollBy,H as scrollIntoView};